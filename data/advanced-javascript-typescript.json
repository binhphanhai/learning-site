{
  "title": "Advanced JavaScript & TypeScript",
  "description": "Master advanced JavaScript concepts and TypeScript type system for senior-level development",
  "sections": [
    {
      "id": "es6-features",
      "title": "Deep Understanding of ES6+ Features",
      "content": [
        {
          "type": "heading",
          "text": "ES6+ Core Features"
        },
        {
          "type": "paragraph",
          "text": "Modern JavaScript has evolved significantly with ES6 (ES2015) and subsequent versions. Understanding these features deeply is crucial for writing efficient, maintainable code."
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Let vs Const vs Var\n// Block scoping and temporal dead zone\nfunction demonstrateScoping() {\n  console.log(varVariable); // undefined (hoisted)\n  // console.log(letVariable); // ReferenceError: Cannot access before initialization\n  // console.log(constVariable); // ReferenceError: Cannot access before initialization\n  \n  var varVariable = 'var';\n  let letVariable = 'let';\n  const constVariable = 'const';\n  \n  if (true) {\n    var varInBlock = 'var in block'; // Function scoped\n    let letInBlock = 'let in block'; // Block scoped\n    const constInBlock = 'const in block'; // Block scoped\n  }\n  \n  console.log(varInBlock); // 'var in block'\n  // console.log(letInBlock); // ReferenceError\n  // console.log(constInBlock); // ReferenceError\n}"
        },
        {
          "type": "heading",
          "text": "Arrow Functions Deep Dive"
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Arrow function behavior with 'this'\nclass EventHandler {\n  constructor() {\n    this.name = 'EventHandler';\n  }\n  \n  // Regular function - 'this' depends on call context\n  regularMethod() {\n    console.log(this.name);\n  }\n  \n  // Arrow function - 'this' is lexically bound\n  arrowMethod = () => {\n    console.log(this.name);\n  }\n  \n  setupEventListeners() {\n    const button = document.querySelector('button');\n    \n    // This will lose context\n    button.addEventListener('click', this.regularMethod); // undefined\n    \n    // This preserves context\n    button.addEventListener('click', this.arrowMethod); // 'EventHandler'\n    \n    // Alternative with bind\n    button.addEventListener('click', this.regularMethod.bind(this));\n  }\n}"
        },
        {
          "type": "heading",
          "text": "Destructuring Advanced Patterns"
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Advanced destructuring patterns\nconst user = {\n  id: 1,\n  name: 'John Doe',\n  email: 'john@example.com',\n  address: {\n    street: '123 Main St',\n    city: 'New York',\n    country: 'USA'\n  },\n  preferences: {\n    theme: 'dark',\n    notifications: true\n  }\n};\n\n// Nested destructuring with renaming and defaults\nconst {\n  name: userName,\n  email,\n  address: {\n    city,\n    country,\n    zipCode = 'N/A' // Default if not present\n  },\n  preferences: {\n    theme = 'light',\n    notifications: enableNotifications\n  }\n} = user;\n\n// Array destructuring with rest\nconst [first, second, ...rest] = [1, 2, 3, 4, 5];\nconsole.log(first, second, rest); // 1 2 [3, 4, 5]\n\n// Function parameter destructuring\nfunction processUser({ name, email, age = 18 }) {\n  console.log(`Processing ${name} (${email}), age: ${age}`);\n}\n\n// Swapping variables\nlet a = 1, b = 2;\n[a, b] = [b, a];\nconsole.log(a, b); // 2 1"
        }
      ]
    },
    {
      "id": "typescript-advanced",
      "title": "TypeScript Advanced Types and Generics",
      "content": [
        {
          "type": "heading",
          "text": "Advanced Type System"
        },
        {
          "type": "paragraph",
          "text": "TypeScript's type system is incredibly powerful and allows for complex type relationships that enable better code safety and developer experience."
        },
        {
          "type": "code",
          "language": "typescript",
          "text": "// Utility types and type manipulation\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n  isActive: boolean;\n}\n\n// Partial - makes all properties optional\ntype PartialUser = Partial<User>;\n// { id?: number; name?: string; email?: string; age?: number; isActive?: boolean }\n\n// Pick - select specific properties\ntype UserBasicInfo = Pick<User, 'id' | 'name' | 'email'>;\n// { id: number; name: string; email: string }\n\n// Omit - exclude specific properties\ntype UserWithoutId = Omit<User, 'id'>;\n// { name: string; email: string; age: number; isActive: boolean }\n\n// Required - makes all properties required\ntype RequiredUser = Required<PartialUser>;\n// Same as User\n\n// Record - create object type with specific keys and values\ntype UserRoles = Record<'admin' | 'user' | 'guest', string[]>;\n// { admin: string[]; user: string[]; guest: string[] }"
        },
        {
          "type": "heading",
          "text": "Generics and Constraints"
        },
        {
          "type": "code",
          "language": "typescript",
          "text": "// Generic functions with constraints\ninterface Identifiable {\n  id: number;\n}\n\ninterface Timestamped {\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Generic with multiple constraints\nfunction updateEntity<T extends Identifiable & Timestamped>(\n  entity: T,\n  updates: Partial<Omit<T, 'id' | 'createdAt'>>\n): T {\n  return {\n    ...entity,\n    ...updates,\n    updatedAt: new Date()\n  };\n}\n\n// Conditional types\ntype ApiResponse<T> = T extends string \n  ? { message: T } \n  : T extends number \n    ? { count: T }\n    : { data: T };\n\ntype StringResponse = ApiResponse<string>; // { message: string }\ntype NumberResponse = ApiResponse<number>; // { count: number }\ntype ObjectResponse = ApiResponse<User>; // { data: User }\n\n// Mapped types\ntype Optional<T> = {\n  [P in keyof T]?: T[P];\n};\n\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\n// Template literal types\ntype EventName<T extends string> = `on${Capitalize<T>}`;\ntype ClickEvent = EventName<'click'>; // 'onClick'\ntype SubmitEvent = EventName<'submit'>; // 'onSubmit'"
        }
      ]
    },
    {
      "id": "async-programming",
      "title": "Asynchronous Programming",
      "content": [
        {
          "type": "heading",
          "text": "Promises and Async/Await"
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Promise patterns and error handling\nclass ApiClient {\n  constructor(baseURL) {\n    this.baseURL = baseURL;\n  }\n  \n  async request(endpoint, options = {}) {\n    try {\n      const response = await fetch(`${this.baseURL}${endpoint}`, {\n        ...options,\n        headers: {\n          'Content-Type': 'application/json',\n          ...options.headers\n        }\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error('API request failed:', error);\n      throw error;\n    }\n  }\n  \n  // Parallel requests with Promise.all\n  async getUserData(userId) {\n    try {\n      const [user, posts, comments] = await Promise.all([\n        this.request(`/users/${userId}`),\n        this.request(`/users/${userId}/posts`),\n        this.request(`/users/${userId}/comments`)\n      ]);\n      \n      return { user, posts, comments };\n    } catch (error) {\n      // If any request fails, all fail\n      throw new Error(`Failed to fetch user data: ${error.message}`);\n    }\n  }\n  \n  // Race condition with timeout\n  async requestWithTimeout(endpoint, timeout = 5000) {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n    \n    try {\n      const response = await this.request(endpoint, {\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      return response;\n    } catch (error) {\n      clearTimeout(timeoutId);\n      if (error.name === 'AbortError') {\n        throw new Error('Request timed out');\n      }\n      throw error;\n    }\n  }\n}"
        },
        {
          "type": "heading",
          "text": "Event Loop and Microtasks"
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Understanding event loop execution order\nconsole.log('1. Start');\n\n// Macrotask (setTimeout)\nsetTimeout(() => {\n  console.log('5. Timeout callback');\n}, 0);\n\n// Microtask (Promise)\nPromise.resolve().then(() => {\n  console.log('4. Promise callback');\n});\n\n// Synchronous code\nconsole.log('2. Synchronous');\n\n// Another microtask\nqueueMicrotask(() => {\n  console.log('3. Microtask');\n});\n\nconsole.log('6. End');\n\n// Output order:\n// 1. Start\n// 2. Synchronous\n// 6. End\n// 3. Microtask\n// 4. Promise callback\n// 5. Timeout callback\n\n// Async iterator example\nclass AsyncNumberGenerator {\n  constructor(max) {\n    this.max = max;\n  }\n  \n  async *[Symbol.asyncIterator]() {\n    for (let i = 0; i < this.max; i++) {\n      // Simulate async operation\n      await new Promise(resolve => setTimeout(resolve, 100));\n      yield i;\n    }\n  }\n}\n\n// Usage\nasync function processNumbers() {\n  const generator = new AsyncNumberGenerator(5);\n  \n  for await (const num of generator) {\n    console.log(`Generated: ${num}`);\n  }\n}"
        }
      ]
    },
    {
      "id": "functional-programming",
      "title": "Functional Programming Concepts",
      "content": [
        {
          "type": "heading",
          "text": "Pure Functions and Immutability"
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Pure functions - same input always produces same output\n// No side effects\nfunction add(a, b) {\n  return a + b; // Pure\n}\n\nlet counter = 0;\nfunction impureIncrement() {\n  counter++; // Impure - modifies external state\n  return counter;\n}\n\nfunction pureIncrement(value) {\n  return value + 1; // Pure - no external dependencies\n}\n\n// Immutable data structures\nconst originalArray = [1, 2, 3];\n\n// Immutable operations\nconst newArray = [...originalArray, 4]; // [1, 2, 3, 4]\nconst mappedArray = originalArray.map(x => x * 2); // [2, 4, 6]\nconst filteredArray = originalArray.filter(x => x > 1); // [2, 3]\n\n// Object immutability\nconst originalObject = { name: 'John', age: 30 };\nconst updatedObject = {\n  ...originalObject,\n  age: 31\n};\n\n// Deep immutability helper\nfunction deepFreeze(obj) {\n  Object.getOwnPropertyNames(obj).forEach(name => {\n    const value = obj[name];\n    if (value && typeof value === 'object') {\n      deepFreeze(value);\n    }\n  });\n  return Object.freeze(obj);\n}"
        },
        {
          "type": "heading",
          "text": "Higher-Order Functions and Composition"
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Higher-order functions\nfunction withLogging(fn) {\n  return function(...args) {\n    console.log(`Calling ${fn.name} with args:`, args);\n    const result = fn.apply(this, args);\n    console.log(`Result:`, result);\n    return result;\n  };\n}\n\nfunction withRetry(fn, maxRetries = 3) {\n  return async function(...args) {\n    let lastError;\n    \n    for (let i = 0; i <= maxRetries; i++) {\n      try {\n        return await fn.apply(this, args);\n      } catch (error) {\n        lastError = error;\n        if (i === maxRetries) break;\n        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n      }\n    }\n    \n    throw lastError;\n  };\n}\n\n// Function composition\nfunction compose(...fns) {\n  return function(value) {\n    return fns.reduceRight((acc, fn) => fn(acc), value);\n  };\n}\n\nfunction pipe(...fns) {\n  return function(value) {\n    return fns.reduce((acc, fn) => fn(acc), value);\n  };\n}\n\n// Example usage\nconst multiply = x => x * 2;\nconst add = x => x + 1;\nconst square = x => x * x;\n\nconst composedFn = compose(square, add, multiply);\nconst pipedFn = pipe(multiply, add, square);\n\nconsole.log(composedFn(3)); // square(add(multiply(3))) = square(7) = 49\nconsole.log(pipedFn(3)); // square(add(multiply(3))) = square(7) = 49\n\n// Currying\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function(...nextArgs) {\n        return curried.apply(this, args.concat(nextArgs));\n      };\n    }\n  };\n}\n\nconst multiply3 = (a, b, c) => a * b * c;\nconst curriedMultiply = curry(multiply3);\n\nconsole.log(curriedMultiply(2)(3)(4)); // 24\nconsole.log(curriedMultiply(2, 3)(4)); // 24\nconsole.log(curriedMultiply(2)(3, 4)); // 24"
        }
      ]
    }
  ],
  "testQuestions": [
    {
      "id": 1,
      "question": "What is the main difference between 'let' and 'var' in JavaScript?",
      "options": [
        "let is function-scoped, var is block-scoped",
        "let is block-scoped, var is function-scoped",
        "let can be redeclared, var cannot",
        "There is no difference"
      ],
      "correctAnswer": 1,
      "explanation": "'let' is block-scoped, meaning it's only accessible within the nearest enclosing block, while 'var' is function-scoped and accessible throughout the entire function."
    },
    {
      "id": 2,
      "question": "What will be the output of this code?\n```javascript\nconsole.log(a);\nvar a = 5;\nconsole.log(a);\n```",
      "options": [
        "ReferenceError, 5",
        "undefined, 5",
        "5, 5",
        "undefined, undefined"
      ],
      "correctAnswer": 1,
      "explanation": "Due to hoisting, 'var a' is moved to the top but its assignment stays in place. So 'a' is undefined initially, then becomes 5 after assignment."
    },
    {
      "id": 3,
      "question": "In TypeScript, what does the 'keyof' operator do?",
      "options": [
        "Creates a new object with specified keys",
        "Returns the keys of an object as an array",
        "Creates a union type of all property names of a type",
        "Checks if a key exists in an object"
      ],
      "correctAnswer": 2,
      "explanation": "The 'keyof' operator creates a union type consisting of all property names of a given type. For example, if T = {a: string, b: number}, then keyof T = 'a' | 'b'."
    },
    {
      "id": 4,
      "question": "What is the correct way to handle errors in async/await?",
      "options": [
        "Use .catch() method",
        "Use try/catch blocks",
        "Use error callbacks",
        "Errors are handled automatically"
      ],
      "correctAnswer": 1,
      "explanation": "When using async/await, errors should be handled using try/catch blocks around the await statements."
    },
    {
      "id": 5,
      "question": "What is a closure in JavaScript?",
      "options": [
        "A function that returns another function",
        "A function that has access to variables in its outer scope even after the outer function returns",
        "A function that is immediately invoked",
        "A function that doesn't return anything"
      ],
      "correctAnswer": 1,
      "explanation": "A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned. This is due to JavaScript's lexical scoping."
    },
    {
      "id": 6,
      "question": "What is the difference between Promise.all() and Promise.allSettled()?",
      "options": [
        "Promise.all() waits for all promises, Promise.allSettled() waits for the first one",
        "Promise.all() fails if any promise rejects, Promise.allSettled() waits for all regardless of outcome",
        "They are the same",
        "Promise.allSettled() is faster"
      ],
      "correctAnswer": 1,
      "explanation": "Promise.all() fails fast - if any promise rejects, the entire Promise.all() rejects. Promise.allSettled() waits for all promises to settle (either resolve or reject) and returns an array with the outcome of each."
    },
    {
      "id": 7,
      "question": "What does the TypeScript utility type 'Partial<T>' do?",
      "options": [
        "Makes all properties of T required",
        "Makes all properties of T optional",
        "Picks some properties from T",
        "Excludes properties from T"
      ],
      "correctAnswer": 1,
      "explanation": "Partial<T> is a utility type that makes all properties of type T optional. It's equivalent to { [P in keyof T]?: T[P] }."
    },
    {
      "id": 8,
      "question": "What is the temporal dead zone in JavaScript?",
      "options": [
        "The time when a variable is being garbage collected",
        "The time between entering a scope and the variable declaration being reached",
        "The time when a function is being executed",
        "The time when a promise is pending"
      ],
      "correctAnswer": 1,
      "explanation": "The temporal dead zone is the time between entering a scope and the actual declaration of a let or const variable. During this time, the variable cannot be accessed."
    },
    {
      "id": 9,
      "question": "What is the purpose of the 'readonly' modifier in TypeScript?",
      "options": [
        "Makes a property private",
        "Makes a property protected",
        "Makes a property immutable after initialization",
        "Makes a property static"
      ],
      "correctAnswer": 2,
      "explanation": "The 'readonly' modifier makes a property immutable after initialization. It can only be assigned during declaration or in the constructor."
    },
    {
      "id": 10,
      "question": "What is the output of this code?\n```javascript\nfor (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 0);\n}\n```",
      "options": [
        "0, 1, 2",
        "3, 3, 3",
        "0, 0, 0",
        "undefined, undefined, undefined"
      ],
      "correctAnswer": 1,
      "explanation": "Due to closure and var being function-scoped, all setTimeout callbacks share the same 'i' variable. By the time they execute, the loop has completed and i equals 3."
    },
    {
      "id": 11,
      "question": "What is the difference between == and === in JavaScript?",
      "options": [
        "No difference",
        "== checks type and value, === checks only value",
        "== performs type coercion, === checks type and value without coercion",
        "=== is deprecated"
      ],
      "correctAnswer": 2,
      "explanation": "== performs type coercion before comparison, while === checks both type and value without any coercion (strict equality)."
    },
    {
      "id": 12,
      "question": "What is the result of typeof null in JavaScript?",
      "options": [
        "'null'",
        "'undefined'",
        "'object'",
        "'boolean'"
      ],
      "correctAnswer": 2,
      "explanation": "typeof null returns 'object'. This is a well-known JavaScript quirk/bug that has been kept for backward compatibility."
    },
    {
      "id": 13,
      "question": "What is the purpose of the 'use strict' directive?",
      "options": [
        "Makes code run faster",
        "Enables ES6 features",
        "Enforces stricter parsing and error handling",
        "Enables TypeScript compilation"
      ],
      "correctAnswer": 2,
      "explanation": "'use strict' enables strict mode, which catches common coding mistakes, prevents unsafe actions, and disables confusing features."
    },
    {
      "id": 14,
      "question": "What is a higher-order function?",
      "options": [
        "A function that returns a number",
        "A function that takes another function as argument or returns a function",
        "A function that is defined inside another function",
        "A function that uses async/await"
      ],
      "correctAnswer": 1,
      "explanation": "A higher-order function is a function that takes one or more functions as arguments or returns a function as its result."
    },
    {
      "id": 15,
      "question": "What is the TypeScript never type used for?",
      "options": [
        "Variables that are always null",
        "Functions that never return or always throw",
        "Optional properties",
        "Dynamic types"
      ],
      "correctAnswer": 1,
      "explanation": "The never type represents values that never occur. It's used for functions that never return (infinite loops, always throw errors) or unreachable code."
    },
    {
      "id": 16,
      "question": "What is the difference between Promise.race() and Promise.any()?",
      "options": [
        "They are the same",
        "Promise.race() returns first settled, Promise.any() returns first fulfilled",
        "Promise.any() is faster",
        "Promise.race() only works with arrays"
      ],
      "correctAnswer": 1,
      "explanation": "Promise.race() returns the first promise that settles (either resolves or rejects), while Promise.any() returns the first promise that fulfills (resolves)."
    },
    {
      "id": 17,
      "question": "What is the purpose of WeakMap in JavaScript?",
      "options": [
        "To store key-value pairs with weak references to keys",
        "To store arrays with weak references",
        "To create lightweight objects",
        "To store primitive values only"
      ],
      "correctAnswer": 0,
      "explanation": "WeakMap stores key-value pairs where keys are objects and are held weakly, meaning they can be garbage collected if there are no other references to them."
    },
    {
      "id": 18,
      "question": "What is the difference between for...in and for...of loops?",
      "options": [
        "No difference",
        "for...in iterates over keys, for...of iterates over values",
        "for...of is only for arrays",
        "for...in is deprecated"
      ],
      "correctAnswer": 1,
      "explanation": "for...in iterates over enumerable property names (keys), while for...of iterates over iterable values."
    },
    {
      "id": 19,
      "question": "What is the TypeScript unknown type?",
      "options": [
        "Same as any",
        "A type-safe alternative to any",
        "For undefined values",
        "For null values"
      ],
      "correctAnswer": 1,
      "explanation": "unknown is a type-safe alternative to any. You must perform type checking before using a value of type unknown."
    },
    {
      "id": 20,
      "question": "What is the result of 0.1 + 0.2 === 0.3 in JavaScript?",
      "options": [
        "true",
        "false",
        "undefined",
        "throws an error"
      ],
      "correctAnswer": 1,
      "explanation": "This evaluates to false due to floating-point precision issues. 0.1 + 0.2 equals 0.30000000000000004 in JavaScript."
    },
    {
      "id": 21,
      "question": "What is the purpose of the bind() method?",
      "options": [
        "To combine two functions",
        "To create a new function with a specific 'this' value",
        "To execute a function immediately",
        "To clone a function"
      ],
      "correctAnswer": 1,
      "explanation": "bind() creates a new function with a specific 'this' value and optionally preset arguments."
    },
    {
      "id": 22,
      "question": "What is the difference between call() and apply()?",
      "options": [
        "No difference",
        "call() takes arguments individually, apply() takes an array of arguments",
        "apply() is deprecated",
        "call() is faster"
      ],
      "correctAnswer": 1,
      "explanation": "call() takes arguments individually, while apply() takes an array of arguments. Both invoke the function with a specific 'this' value."
    },
    {
      "id": 23,
      "question": "What is a generator function in JavaScript?",
      "options": [
        "A function that creates objects",
        "A function that can pause and resume execution",
        "A function that runs automatically",
        "A function that generates random numbers"
      ],
      "correctAnswer": 1,
      "explanation": "A generator function can pause and resume execution using yield statements, allowing for creation of iterators and handling of asynchronous operations."
    },
    {
      "id": 24,
      "question": "What is the TypeScript intersection type (&)?",
      "options": [
        "Combines multiple types into one with all properties",
        "Chooses one type from multiple options",
        "Creates optional properties",
        "Excludes properties"
      ],
      "correctAnswer": 0,
      "explanation": "Intersection types (&) combine multiple types into one that has all properties and methods of the combined types."
    },
    {
      "id": 25,
      "question": "What is the purpose of Object.freeze()?",
      "options": [
        "To make object properties read-only",
        "To copy an object",
        "To delete object properties",
        "To sort object properties"
      ],
      "correctAnswer": 0,
      "explanation": "Object.freeze() makes an object immutable - you cannot add, delete, or modify its properties."
    },
    {
      "id": 26,
      "question": "What is the difference between shallow and deep copying?",
      "options": [
        "No difference",
        "Shallow copy copies only first level, deep copy copies all nested levels",
        "Deep copy is faster",
        "Shallow copy creates new objects"
      ],
      "correctAnswer": 1,
      "explanation": "Shallow copy copies only the first level of properties, while deep copy recursively copies all nested objects and arrays."
    },
    {
      "id": 27,
      "question": "What is the purpose of the Proxy object?",
      "options": [
        "To create object copies",
        "To intercept and customize operations on objects",
        "To create private properties",
        "To improve performance"
      ],
      "correctAnswer": 1,
      "explanation": "Proxy allows you to intercept and customize operations performed on objects (property access, assignment, enumeration, function invocation, etc.)."
    },
    {
      "id": 28,
      "question": "What is the difference between Map and Object in JavaScript?",
      "options": [
        "No difference",
        "Map can have any type of keys, Object keys are strings/symbols",
        "Object is faster",
        "Map is deprecated"
      ],
      "correctAnswer": 1,
      "explanation": "Map can have keys of any type, while Object keys must be strings or symbols. Map also has better performance for frequent additions/deletions."
    },
    {
      "id": 29,
      "question": "What is the TypeScript void type?",
      "options": [
        "For null values",
        "For undefined values",
        "For functions that don't return a value",
        "For empty objects"
      ],
      "correctAnswer": 2,
      "explanation": "void is used for functions that don't return a value. It indicates the absence of a return value."
    },
    {
      "id": 30,
      "question": "What is event bubbling in JavaScript?",
      "options": [
        "Events that create bubbles",
        "Events that propagate from target to root",
        "Events that are cancelled",
        "Events that repeat"
      ],
      "correctAnswer": 1,
      "explanation": "Event bubbling is when an event propagates from the target element up through its ancestors in the DOM tree."
    },
    {
      "id": 31,
      "question": "What is the difference between stopPropagation() and preventDefault()?",
      "options": [
        "They are the same",
        "stopPropagation() stops event bubbling, preventDefault() stops default behavior",
        "preventDefault() is deprecated",
        "stopPropagation() is faster"
      ],
      "correctAnswer": 1,
      "explanation": "stopPropagation() stops the event from bubbling up the DOM tree, while preventDefault() prevents the default action associated with the event."
    },
    {
      "id": 32,
      "question": "What is the purpose of the Symbol type?",
      "options": [
        "To create unique identifiers",
        "To store numbers",
        "To create strings",
        "To create arrays"
      ],
      "correctAnswer": 0,
      "explanation": "Symbol creates unique identifiers that can be used as object property keys without risk of name collisions."
    },
    {
      "id": 33,
      "question": "What is the difference between function declarations and function expressions?",
      "options": [
        "No difference",
        "Declarations are hoisted, expressions are not",
        "Expressions are faster",
        "Declarations are deprecated"
      ],
      "correctAnswer": 1,
      "explanation": "Function declarations are hoisted (can be called before they're defined), while function expressions are not hoisted."
    },
    {
      "id": 34,
      "question": "What is the TypeScript tuple type?",
      "options": [
        "An array with fixed length and types",
        "An object with fixed properties",
        "A function with fixed parameters",
        "A string with fixed length"
      ],
      "correctAnswer": 0,
      "explanation": "A tuple is an array with a fixed number of elements of specific types in a specific order."
    },
    {
      "id": 35,
      "question": "What is the purpose of async/await?",
      "options": [
        "To make code run faster",
        "To handle asynchronous operations with synchronous-like syntax",
        "To create multiple threads",
        "To handle errors only"
      ],
      "correctAnswer": 1,
      "explanation": "async/await provides a way to write asynchronous code that looks and behaves more like synchronous code, making it easier to read and understand."
    }
  ]
} 