{
  "title": "Business & Product Strategy",
  "description": "Master technical strategy alignment, product engineering, scalability planning, risk management, and cost optimization for senior-level business impact and strategic decision making",
  "sections": [
    {
      "id": "technical-strategy-alignment",
      "title": "Technical Strategy Alignment & Roadmap Planning",
      "content": [
        {
          "type": "heading",
          "text": "Technical Vision & Strategy Framework"
        },
        {
          "type": "paragraph",
          "text": "Aligning technical decisions with business objectives requires a structured approach to strategy development, stakeholder communication, and roadmap planning."
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Technical Strategy Framework Implementation\nclass TechnicalStrategyFramework {\n  constructor() {\n    this.objectives = new Map();\n    this.initiatives = new Map();\n    this.metrics = new Map();\n    this.stakeholders = new Map();\n    this.dependencies = new Map();\n  }\n\n  defineObjective(id, config) {\n    this.objectives.set(id, {\n      title: config.title,\n      description: config.description,\n      businessValue: config.businessValue,\n      timeframe: config.timeframe,\n      successMetrics: config.successMetrics,\n      risks: config.risks || [],\n      dependencies: config.dependencies || [],\n      stakeholders: config.stakeholders || [],\n      status: 'planned',\n      createdAt: new Date(),\n      ...config\n    });\n  }\n\n  createInitiative(objectiveId, initiativeConfig) {\n    const objective = this.objectives.get(objectiveId);\n    if (!objective) {\n      throw new Error(`Objective ${objectiveId} not found`);\n    }\n\n    const initiativeId = `${objectiveId}-${Date.now()}`;\n    this.initiatives.set(initiativeId, {\n      id: initiativeId,\n      objectiveId,\n      title: initiativeConfig.title,\n      description: initiativeConfig.description,\n      effort: initiativeConfig.effort,\n      priority: initiativeConfig.priority,\n      complexity: initiativeConfig.complexity,\n      riskLevel: initiativeConfig.riskLevel,\n      requiredSkills: initiativeConfig.requiredSkills || [],\n      estimatedDuration: initiativeConfig.estimatedDuration,\n      dependencies: initiativeConfig.dependencies || [],\n      deliverables: initiativeConfig.deliverables || [],\n      status: 'backlog',\n      createdAt: new Date()\n    });\n\n    return initiativeId;\n  }\n\n  generateRoadmap(timeframe = '12months') {\n    const roadmap = {\n      timeframe,\n      objectives: [],\n      timeline: this.createTimeline(timeframe),\n      resourceAllocation: this.calculateResourceAllocation(),\n      criticalPath: this.calculateCriticalPath(),\n      riskAssessment: this.assessRisks(),\n      milestones: this.defineMilestones()\n    };\n\n    const sortedObjectives = Array.from(this.objectives.values())\n      .sort((a, b) => {\n        const aScore = a.businessValue * this.getUrgencyScore(a);\n        const bScore = b.businessValue * this.getUrgencyScore(b);\n        return bScore - aScore;\n      });\n\n    roadmap.objectives = sortedObjectives.map(objective => ({\n      ...objective,\n      initiatives: this.getInitiativesForObjective(objective.id),\n      estimatedCompletion: this.calculateCompletionDate(objective.id),\n      resourceRequirements: this.calculateResourceRequirements(objective.id)\n    }));\n\n    return roadmap;\n  }\n\n  generateStakeholderReport(stakeholderType) {\n    const relevantObjectives = Array.from(this.objectives.values())\n      .filter(obj => obj.stakeholders.includes(stakeholderType));\n\n    const report = {\n      stakeholderType,\n      generatedAt: new Date(),\n      executiveSummary: this.generateExecutiveSummary(relevantObjectives),\n      keyMetrics: this.getKeyMetrics(relevantObjectives),\n      progress: this.calculateProgress(relevantObjectives),\n      upcomingMilestones: this.getUpcomingMilestones(relevantObjectives),\n      risks: this.getRelevantRisks(relevantObjectives),\n      recommendations: this.generateRecommendations(relevantObjectives)\n    };\n\n    switch (stakeholderType) {\n      case 'executive':\n        return this.formatExecutiveReport(report);\n      case 'product':\n        return this.formatProductReport(report);\n      case 'engineering':\n        return this.formatEngineeringReport(report);\n      default:\n        return report;\n    }\n  }\n\n  createBusinessCase(initiativeId) {\n    const initiative = this.initiatives.get(initiativeId);\n    if (!initiative) {\n      throw new Error(`Initiative ${initiativeId} not found`);\n    }\n\n    const businessCase = {\n      initiative: initiative.title,\n      executiveSummary: this.generateExecutiveSummary([initiative]),\n      problemStatement: this.defineProblemStatement(initiative),\n      proposedSolution: initiative.description,\n      businessValue: {\n        revenueImpact: this.calculateRevenueImpact(initiative),\n        costSavings: this.calculateCostSavings(initiative),\n        riskMitigation: this.calculateRiskMitigation(initiative),\n        strategicValue: this.assessStrategicValue(initiative)\n      },\n      investment: {\n        developmentCost: this.calculateDevelopmentCost(initiative),\n        maintenanceCost: this.calculateMaintenanceCost(initiative),\n        opportunityCost: this.calculateOpportunityCost(initiative),\n        totalCost: 0\n      },\n      timeline: {\n        phases: this.defineProjectPhases(initiative),\n        milestones: this.defineProjectMilestones(initiative),\n        dependencies: initiative.dependencies\n      },\n      riskAnalysis: {\n        technicalRisks: this.assessTechnicalRisks(initiative),\n        businessRisks: this.assessBusinessRisks(initiative),\n        mitigationStrategies: this.defineMitigationStrategies(initiative)\n      },\n      successMetrics: this.defineSuccessMetrics(initiative),\n      alternatives: this.identifyAlternatives(initiative)\n    };\n\n    businessCase.investment.totalCost = \n      businessCase.investment.developmentCost +\n      businessCase.investment.maintenanceCost +\n      businessCase.investment.opportunityCost;\n\n    const totalBenefit = \n      businessCase.businessValue.revenueImpact +\n      businessCase.businessValue.costSavings +\n      businessCase.businessValue.riskMitigation;\n    \n    businessCase.roi = {\n      netPresentValue: this.calculateNPV(totalBenefit, businessCase.investment.totalCost),\n      returnOnInvestment: ((totalBenefit - businessCase.investment.totalCost) / businessCase.investment.totalCost) * 100,\n      paybackPeriod: this.calculatePaybackPeriod(totalBenefit, businessCase.investment.totalCost),\n      internalRateOfReturn: this.calculateIRR(totalBenefit, businessCase.investment.totalCost)\n    };\n\n    return businessCase;\n  }\n\n  calculateRevenueImpact(initiative) {\n    const metrics = {\n      userGrowth: 0,\n      conversionImprovement: 0,\n      averageOrderValue: 0,\n      retentionImprovement: 0\n    };\n\n    if (initiative.title.includes('performance')) {\n      metrics.conversionImprovement = 0.15;\n      metrics.userGrowth = 0.05;\n    }\n\n    if (initiative.title.includes('feature')) {\n      metrics.averageOrderValue = 0.10;\n      metrics.retentionImprovement = 0.08;\n    }\n\n    const currentRevenue = 1000000;\n    const revenueImpact = currentRevenue * (\n      metrics.userGrowth +\n      metrics.conversionImprovement +\n      metrics.averageOrderValue +\n      metrics.retentionImprovement\n    );\n\n    return Math.round(revenueImpact);\n  }\n\n  integrateCompetitiveAnalysis(analysis) {\n    const competitiveInsights = {\n      marketPosition: analysis.marketPosition,\n      competitorCapabilities: analysis.competitors.map(comp => ({\n        name: comp.name,\n        strengths: comp.strengths,\n        weaknesses: comp.weaknesses,\n        technicalCapabilities: comp.technicalCapabilities\n      })),\n      opportunityGaps: this.identifyOpportunityGaps(analysis),\n      threatAssessment: this.assessCompetitiveThreats(analysis),\n      strategicRecommendations: this.generateCompetitiveStrategy(analysis)\n    };\n\n    this.updateObjectivesFromCompetitiveAnalysis(competitiveInsights);\n    return competitiveInsights;\n  }\n\n  getUrgencyScore(objective) {\n    const now = new Date();\n    const timeframe = new Date(objective.timeframe);\n    const daysRemaining = (timeframe - now) / (1000 * 60 * 60 * 24);\n    \n    if (daysRemaining < 30) return 5;\n    if (daysRemaining < 90) return 4;\n    if (daysRemaining < 180) return 3;\n    if (daysRemaining < 365) return 2;\n    return 1;\n  }\n\n  calculateNPV(benefit, cost, discountRate = 0.1, years = 3) {\n    let npv = -cost;\n    \n    for (let year = 1; year <= years; year++) {\n      npv += benefit / Math.pow(1 + discountRate, year);\n    }\n    \n    return Math.round(npv);\n  }\n\n  calculatePaybackPeriod(benefit, cost) {\n    return Math.ceil(cost / (benefit / 12));\n  }\n\n  generateExecutiveSummary(objectives) {\n    return {\n      totalObjectives: objectives.length,\n      completedObjectives: objectives.filter(obj => obj.status === 'completed').length,\n      inProgressObjectives: objectives.filter(obj => obj.status === 'in-progress').length,\n      totalBusinessValue: objectives.reduce((sum, obj) => sum + obj.businessValue, 0),\n      keyAchievements: objectives .filter(obj => obj.status === 'completed') .map(obj => obj.title) .slice(0, 3), upcomingMilestones: objectives .filter(obj => obj.status === 'in-progress') .map(obj => ({ title: obj.title, expectedCompletion: obj.expectedCompletion })) .slice(0, 5) };\n  }\n}"
        },
        {
          "type": "heading",
          "text": "Roadmap Planning & Communication"
        },
        {
          "type": "paragraph",
          "text": "Effective roadmap planning requires balancing technical debt, feature development, and strategic initiatives while maintaining clear communication with stakeholders."
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Advanced Roadmap Planning System\nclass RoadmapPlanner {\n  constructor() {\n    this.themes = new Map();\n    this.epics = new Map();\n    this.features = new Map();\n    this.releases = new Map();\n    this.dependencies = new Map();\n    this.constraints = new Map();\n  }\n\n  defineTheme(id, config) {\n    this.themes.set(id, {\n      id, name: config.name, description: config.description, businessObjective: config.businessObjective, successMetrics: config.successMetrics, timeframe: config.timeframe, budget: config.budget, stakeholders: config.stakeholders, priority: config.priority, status: 'active' });\n  }\n\n  createEpic(themeId, epicConfig) {\n    const theme = this.themes.get(themeId);\n    if (!theme) {\n      throw new Error(`Theme ${themeId} not found`);\n    }\n\n    const epicId = `${themeId}-epic-${Date.now()}`;\n    this.epics.set(epicId, {\n      id: epicId, themeId, title: epicConfig.title, description: epicConfig.description, businessValue: epicConfig.businessValue, effort: epicConfig.effort, complexity: epicConfig.complexity, riskLevel: epicConfig.riskLevel, acceptanceCriteria: epicConfig.acceptanceCriteria, dependencies: epicConfig.dependencies || [], targetRelease: epicConfig.targetRelease, assignedTeam: epicConfig.assignedTeam, status: 'backlog', createdAt: new Date() });\n\n    return epicId;\n  }\n\n  generateReleasePlan(timeHorizon = 12) {\n    const releases = [];\n    const startDate = new Date();\n    \n    for (let i = 0; i < timeHorizon; i++) {\n      const releaseDate = new Date(startDate);\n      releaseDate.setMonth(startDate.getMonth() + i);\n      \n      const releaseId = `release-${releaseDate.getFullYear()}-${String(releaseDate.getMonth() + 1).padStart(2, '0')}`;\n      \n      releases.push({\n        id: releaseId, version: this.generateVersionNumber(i), targetDate: releaseDate, theme: this.selectReleaseTheme(releaseDate), capacity: this.calculateReleaseCapacity(releaseDate), plannedFeatures: [], risks: [], dependencies: [], successMetrics: [] });\n    }\n\n    this.assignEpicsToReleases(releases);\n    \n    releases.forEach(release => {\n      release.readiness = this.assessReleaseReadiness(release);\n      release.confidence = this.calculateReleaseConfidence(release);\n    });\n\n    return releases;\n  }\n\n  assignEpicsToReleases(releases) {\n    const availableEpics = Array.from(this.epics.values()) .filter(epic => epic.status === 'backlog') .sort((a, b) => {\n        const aScore = a.businessValue / Math.max(a.complexity, 1);\n        const bScore = b.businessValue / Math.max(b.complexity, 1);\n        return bScore - aScore;\n      });\n\n    releases.forEach(release => {\n      let remainingCapacity = release.capacity;\n      \n      for (const epic of availableEpics) {\n        if (remainingCapacity >= epic.effort && this.canFitInRelease(epic, release)) {\n          release.plannedFeatures.push({\n            epicId: epic.id, title: epic.title, effort: epic.effort, businessValue: epic.businessValue, riskLevel: epic.riskLevel });\n          \n          remainingCapacity -= epic.effort;\n          epic.status = 'planned';\n          epic.targetRelease = release.id;\n          \n          epic.dependencies.forEach(dep => {\n            if (!release.dependencies.includes(dep)) {\n              release.dependencies.push(dep);\n            }\n          });\n        }\n      }\n      \n      release.utilization = ((release.capacity - remainingCapacity) / release.capacity) * 100;\n    });\n  }\n\n  generateStakeholderUpdate(audienceType, timeframe = 'monthly') {\n    const template = {\n      audience: audienceType, timeframe, generatedAt: new Date(), sections: [] };\n\n    switch (audienceType) {\n      case 'executive':\n        template.sections = [\n          this.createExecutiveSummarySection(),\n          this.createBusinessMetricsSection(),\n          this.createRiskAndMitigationSection(),\n          this.createStrategicAlignmentSection(),\n          this.createResourceRequirementsSection()\n        ];\n        break;\n        \n      case 'product':\n        template.sections = [\n          this.createFeatureProgressSection(),\n          this.createUserImpactSection(),\n          this.createMarketCompetitivenessSection(),\n          this.createTechnicalDebtSection(),\n          this.createUpcomingDecisionsSection()\n        ];\n        break;\n        \n      case 'engineering':\n        template.sections = [\n          this.createTechnicalProgressSection(),\n          this.createArchitectureDecisionsSection(),\n          this.createTechnicalChallengesSection(),\n          this.createToolingAndInfrastructureSection(),\n          this.createTeamCapacitySection()\n        ];\n        break;\n    }\n\n    return template;\n  }\n\n  createExecutiveSummarySection() {\n    const activeThemes = Array.from(this.themes.values()) .filter(theme => theme.status === 'active');\n    \n    const completedEpics = Array.from(this.epics.values()) .filter(epic => epic.status === 'completed');\n    \n    const totalBusinessValue = completedEpics .reduce((sum, epic) => sum + epic.businessValue, 0);\n\n    return {\n      title: 'Executive Summary', type: 'summary', data: {\n        activeThemes: activeThemes.length, completedInitiatives: completedEpics.length, businessValueDelivered: totalBusinessValue, keyAchievements: completedEpics .sort((a, b) => b.businessValue - a.businessValue).slice(0, 3).map(epic => ({ title: epic.title, businessValue: epic.businessValue, completedAt: epic.completedAt })), upcomingMilestones: this.getUpcomingMilestones(30) }\n    };\n  }\n\n  trackDecision(decisionConfig) {\n    const decisionId = `decision-${Date.now()}`;\n    \n    const decision = {\n      id: decisionId, title: decisionConfig.title, description: decisionConfig.description, context: decisionConfig.context, options: decisionConfig.options, criteria: decisionConfig.criteria, stakeholders: decisionConfig.stakeholders, decisionMaker: decisionConfig.decisionMaker, deadline: decisionConfig.deadline, impact: decisionConfig.impact, reversibility: decisionConfig.reversibility, status: 'pending', createdAt: new Date(), updatedAt: new Date() };\n\n    decision.complexity = this.analyzeDecisionComplexity(decision);\n    decision.recommendedProcess = this.recommendDecisionProcess(decision);\n    decision.requiredInformation = this.identifyRequiredInformation(decision);\n\n    return decision;\n  }\n\n  analyzeDecisionComplexity(decision) {\n    let complexityScore = 0;\n    \n    complexityScore += decision.stakeholders.length * 2;\n    complexityScore += decision.options.length * 3;\n    complexityScore += decision.impact === 'high' ? 10 : decision.impact === 'medium' ? 5 : 1;\n    complexityScore += decision.reversibility === 'low' ? 8 : decision.reversibility === 'medium' ? 4 : 1;\n    \n    if (complexityScore < 15) return 'low';\n    if (complexityScore < 30) return 'medium';\n    return 'high';\n  }\n\n  recommendDecisionProcess(decision) {\n    const processes = {\n      low: {\n        type: 'individual', steps: [\n          'Gather basic information', 'Evaluate options against criteria', 'Make decision', 'Communicate decision'\n        ], timeframe: '1-3 days'\n      },\n      medium: {\n        type: 'collaborative', steps: [\n          'Define decision criteria with stakeholders', 'Gather comprehensive information', 'Facilitate stakeholder input session', 'Analyze options systematically', 'Build consensus or escalate', 'Document and communicate decision'\n        ], timeframe: '1-2 weeks'\n      },\n      high: {\n        type: 'structured', steps: [\n          'Establish decision committee', 'Conduct thorough research and analysis', 'Create detailed option comparison', 'Run pilot or proof of concept if applicable', 'Facilitate multiple stakeholder sessions', 'Use formal decision-making framework (e.g., RACI, DACI)', 'Document rationale and alternatives', 'Create communication and rollout plan'\n        ], timeframe: '2-6 weeks'\n      }\n    };\n\n    return processes[decision.complexity];\n  }\n}"
        }
      ]
    },
    {
      "id": "product-engineering",
      "title": "Product Engineering & Feature Management",
      "content": [
        {
          "type": "heading",
          "text": "Feature Flag Architecture & A/B Testing"
        },
        {
          "type": "paragraph",
          "text": "Advanced feature management enables controlled rollouts, experimentation, and data-driven product decisions at scale."
        },
        {
          "type": "code",
          "language": "javascript",
          "text": "// Advanced Feature Flag and Experimentation Platform\nclass ExperimentationPlatform {\n  constructor(config = {}) {\n    this.experiments = new Map();\n    this.featureFlags = new Map();\n    this.userSegments = new Map();\n    this.metrics = new Map();\n    this.analyticsProvider = config.analyticsProvider;\n    this.statisticalEngine = new StatisticalEngine();\n  }\n\n  createExperiment(config) {\n    const experimentId = `exp-${Date.now()}`;\n    \n    const experiment = {\n      id: experimentId, name: config.name, hypothesis: config.hypothesis, objective: config.objective, type: config.type || 'a-b', variants: config.variants, trafficAllocation: config.trafficAllocation || 100, targetingRules: config.targetingRules || [], primaryMetric: config.primaryMetric, secondaryMetrics: config.secondaryMetrics || [], guardrailMetrics: config.guardrailMetrics || [], minimumDetectableEffect: config.minimumDetectableEffect || 0.05, statisticalPower: config.statisticalPower || 0.8, significanceLevel: config.significanceLevel || 0.05, duration: config.duration, startDate: config.startDate || new Date(), endDate: config.endDate, status: 'draft', results: null, createdAt: new Date()\n    };\n\n    experiment.requiredSampleSize = this.calculateSampleSize(\n      experiment.minimumDetectableEffect,\n      experiment.statisticalPower,\n      experiment.significanceLevel\n    );\n\n    this.validateExperiment(experiment);\n    this.experiments.set(experimentId, experiment);\n    return experimentId;\n  }\n\n  createUserSegment(name, rules) {\n    const segmentId = `segment-${Date.now()}`;\n    \n    const segment = {\n      id: segmentId, name, rules, estimatedSize: 0, createdAt: new Date(), updatedAt: new Date()\n    };\n\n    segment.estimatedSize = this.estimateSegmentSize(rules);\n    this.userSegments.set(segmentId, segment);\n    return segmentId;\n  }\n\n  assignUserToExperiment(userId, experimentId, userContext = {}) {\n    const experiment = this.experiments.get(experimentId);\n    if (!experiment || experiment.status !== 'running') {\n      return null;\n    }\n\n    if (!this.meetsTargetingCriteria(userContext, experiment.targetingRules)) {\n      return null;\n    }\n\n    const trafficHash = this.hash(`${userId}-${experimentId}-traffic`);\n    if ((trafficHash % 100) >= experiment.trafficAllocation) {\n      return null;\n    }\n\n    const variantHash = this.hash(`${userId}-${experimentId}-variant`);\n    const totalWeight = experiment.variants.reduce((sum, v) => sum + v.weight, 0);\n    let cumulativeWeight = 0;\n    \n    for (const variant of experiment.variants) {\n      cumulativeWeight += variant.weight;\n      if ((variantHash % totalWeight) < cumulativeWeight) {\n        this.trackAssignment(userId, experimentId, variant.id, userContext);\n        return variant;\n      }\n    }\n\n    return experiment.variants[0];\n  }\n\n  createMultiArmedBandit(config) {\n    const banditId = `bandit-${Date.now()}`;\n    \n    const bandit = {\n      id: banditId, name: config.name, arms: config.arms.map(arm => ({\n        ...arm, pulls: 0, rewards: 0, averageReward: 0, confidence: 0, upperConfidenceBound: 0\n      })), strategy: config.strategy || 'ucb1', explorationRate: config.explorationRate || 0.1, totalPulls: 0, createdAt: new Date()\n    };\n\n    this.experiments.set(banditId, bandit);\n    return banditId;\n  }\n\n  selectBanditArm(banditId, userId) {\n    const bandit = this.experiments.get(banditId);\n    if (!bandit) return null;\n\n    let selectedArm;\n    \n    switch (bandit.strategy) {\n      case 'ucb1':\n        selectedArm = this.selectUCB1Arm(bandit);\n        break;\n      case 'epsilon-greedy':\n        selectedArm = this.selectEpsilonGreedyArm(bandit);\n        break;\n      case 'thompson-sampling':\n        selectedArm = this.selectThompsonSamplingArm(bandit);\n        break;\n      default:\n        selectedArm = bandit.arms[0];\n    }\n\n    this.trackBanditSelection(userId, banditId, selectedArm.id);\n    return selectedArm;\n  }\n\n  selectUCB1Arm(bandit) {\n    if (bandit.totalPulls === 0) {\n      return bandit.arms[0];\n    }\n\n    bandit.arms.forEach(arm => {\n      if (arm.pulls === 0) {\n        arm.upperConfidenceBound = Infinity;\n      } else {\n        const confidence = Math.sqrt(\n          (2 * Math.log(bandit.totalPulls)) / arm.pulls\n        );\n        arm.upperConfidenceBound = arm.averageReward + confidence;\n      }\n    });\n\n    return bandit.arms.reduce((best, current) => \n      current.upperConfidenceBound > best.upperConfidenceBound ? current : best\n    );\n  }\n\n  generateExperimentReport(experimentId) {\n    const experiment = this.experiments.get(experimentId);\n    if (!experiment) {\n      throw new Error(`Experiment ${experimentId} not found`);\n    }\n\n    const report = {\n      experiment: experiment.name, id: experimentId, status: experiment.status, duration: this.calculateDuration(experiment), participants: this.getParticipantCount(experimentId), variants: [], statisticalSignificance: null, recommendation: null, confidence: null, generatedAt: new Date()\n    };\n\n    experiment.variants.forEach(variant => {\n      const variantData = this.getVariantData(experimentId, variant.id);\n      \n      report.variants.push({\n        id: variant.id, name: variant.name, participants: variantData.participants, conversionRate: variantData.conversionRate, confidenceInterval: variantData.confidenceInterval, lift: variantData.lift, significance: variantData.significance, metrics: this.calculateVariantMetrics(experimentId, variant.id)\n      });\n    });\n\n    report.statisticalSignificance = this.calculateStatisticalSignificance(report.variants);\n    report.confidence = this.calculateConfidence(report.variants);\n    report.recommendation = this.generateRecommendation(report);\n    report.riskAnalysis = this.analyzeExperimentRisk(experiment, report);\n    report.businessImpact = this.estimateBusinessImpact(experiment, report);\n\n    return report;\n  }\n\n  calculateStatisticalSignificance(variants) {\n    if (variants.length < 2) return null;\n\n    const control = variants[0];\n    const treatment = variants[1];\n\n    const p1 = control.conversionRate;\n    const n1 = control.participants;\n    const p2 = treatment.conversionRate;\n    const n2 = treatment.participants;\n\n    const pooledProportion = (p1 * n1 + p2 * n2) / (n1 + n2);\n    const standardError = Math.sqrt(\n      pooledProportion * (1 - pooledProportion) * (1/n1 + 1/n2)\n    );\n\n    const zScore = (p2 - p1) / standardError;\n    const pValue = 2 * (1 - this.normalCDF(Math.abs(zScore)));\n\n    return {\n      zScore, pValue, isSignificant: pValue < 0.05, confidenceLevel: (1 - pValue) * 100\n    };\n  }\n\n  generateRecommendation(report) {\n    const { variants, statisticalSignificance, confidence } = report;\n    \n    if (!statisticalSignificance || !statisticalSignificance.isSignificant) {\n      return {\n        action: 'continue', reason: 'No statistically significant difference detected', confidence: 'low', nextSteps: [\n          'Continue running experiment to gather more data', 'Consider increasing traffic allocation', 'Review experiment setup and metrics'\n        ]\n      };\n    }\n\n    const winner = variants.reduce((best, current) => \n      current.conversionRate > best.conversionRate ? current : best\n    );\n\n    const lift = ((winner.conversionRate - variants[0].conversionRate) / variants[0].conversionRate) * 100;\n\n    if (lift > 5 && confidence > 95) {\n      return {\n        action: 'implement', winner: winner.name, reason: `${winner.name} shows significant improvement (${lift.toFixed(2)}% lift)`, confidence: 'high', nextSteps: [\n          'Implement winning variant for all users', 'Monitor key metrics for regression', 'Document learnings and update feature'\n        ]\n      };\n    }\n\n    return {\n      action: 'investigate', reason: 'Results show significance but require further analysis', confidence: 'medium', nextSteps: [\n        'Analyze secondary metrics', 'Segment results by user groups', 'Consider running follow-up experiments'\n      ]\n    };\n  }\n\n  hash(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return Math.abs(hash);\n  }\n\n  normalCDF(x) {\n    return 0.5 * (1 + this.erf(x / Math.sqrt(2)));\n  }\n\n  erf(x) {\n    const a1 =  0.254829592;\n    const a2 = -0.284496736;\n    const a3 =  1.421413741;\n    const a4 = -1.453152027;\n    const a5 =  1.061405429;\n    const p  =  0.3275911;\n\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n\n    const t = 1.0 / (1.0 + p * x);\n    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n\n    return sign * y;\n  }\n\n  calculateSampleSize(mde, power, alpha) {\n    const z_alpha = 1.96;\n    const z_beta = 0.84;\n    const p = 0.1;\n    const delta = mde;\n    \n    const n = (2 * Math.pow(z_alpha + z_beta, 2) * p * (1 - p)) / Math.pow(delta, 2);\n    return Math.ceil(n);\n  }\n}"
        }
      ]
    }
  ],
  "testQuestions": [
    {
      "id": 1,
      "question": "What is the primary purpose of a technical strategy framework?",
      "options": [
        "To manage daily development tasks",
        "To align technical decisions with business objectives and measure progress",
        "To track bug fixes and deployments",
        "To manage team schedules"
      ],
      "correctAnswer": 1,
      "explanation": "A technical strategy framework aligns technical initiatives with business objectives, provides measurable outcomes, and ensures strategic decision-making rather than just tactical execution."
    },
    {
      "id": 2,
      "question": "In roadmap planning, what is the most important factor when prioritizing initiatives?",
      "options": [
        "Development complexity only",
        "Business value relative to effort and strategic alignment",
        "Team preferences",
        "Technology trends"
      ],
      "correctAnswer": 1,
      "explanation": "Effective prioritization considers business value relative to effort (ROI), strategic alignment with company objectives, and resource constraints rather than just technical factors."
    },
    {
      "id": 3,
      "question": "What is the main advantage of multi-armed bandit algorithms over traditional A/B testing?",
      "options": [
        "Easier to implement",
        "Dynamic traffic allocation to optimize performance during the experiment",
        "Requires less data",
        "More accurate results"
      ],
      "correctAnswer": 1,
      "explanation": "Multi-armed bandit algorithms dynamically allocate more traffic to better-performing variants during the experiment, reducing opportunity cost compared to fixed A/B tests."
    },
    {
      "id": 4,
      "question": "When creating a business case for a technical initiative, what is the most critical component?",
      "options": [
        "Technical architecture details",
        "Quantified business value and ROI calculation with risk assessment",
        "Team composition",
        "Timeline estimates"
      ],
      "correctAnswer": 1,
      "explanation": "A compelling business case must quantify business value, calculate ROI, assess risks, and demonstrate clear financial benefits to justify the investment in technical initiatives."
    },
    {
      "id": 5,
      "question": "What is the purpose of statistical significance testing in A/B experiments?",
      "options": [
        "To make results look more professional",
        "To determine if observed differences are likely due to chance or real effects",
        "To increase conversion rates",
        "To reduce experiment duration"
      ],
      "correctAnswer": 1,
      "explanation": "Statistical significance testing helps determine whether observed differences between variants are statistically meaningful or could be due to random chance, informing confident decision-making."
    }
  ]
} 